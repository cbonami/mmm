<?xml version="1.0"?>
<!-- $Id$ -->
<document>
  <properties>
    <title>Project Conventions</title>
    <author email="hohwille@users.sourceforge.net">J&#246;rg Hohwiller</author>
  </properties>

  <body>
    <section name="General">
      <p>This project aims to produce high quality software. Therefore it is very
      important that the code is well designed, documented and tested.
      No sub-project should be released (as official version) if it has NOT
      been tested intensively (though it can obviously still have bugs).</p>
    </section>
    <section name="Maven">
      <p>The project is using <a href="http://maven.apache.org">maven</a>
      as build- and management-tool. Therefore the maven conventions apply 
      to this project. If you are NOT familiar with maven please read the 
      following guides:
      <ul>
        <li><a href="http://maven.apache.org/guides/getting-started/index.html">getting started</a></li>
        <li><a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">project layout</a></li>
      </ul>
      </p>
    </section>
    <section name="Code-Style">
      <p>The code produced by this project follows a common code-style.
      To check these rules, configurations for checkstyle and eclipse are 
      provided (see <a href="setup-devel.html">Setup</a>). Further
      there are additional rules to follow:
      <ul>
        <li>Names for classes and interfaces are english words that describe the type briefly.
        They are in the typical caml case (e.g. AbstractWidget). Shortcuts and acronyms are
        NOT capitalized as part of names (e.g. XmlUtil and NOT XMLUtil).</li>
        <li>There are no artificial conventions for interfaces (like <code>I</code> as prefix 
        or <code>IF</code> as suffix).</li>
        <li>The code should be well documented using javadoc. It does NOT help
        just to satisfy checkstyle with some generated javadoc nonsense. Please help
        to maintain the javadoc of the code and make it precise. Make intensive use
        of the {@link FooClass} constructs to specify what you are talking about.
        </li>
      </ul>
      </p>
    </section>
    <section name="Packages">
      <p>The projects package namespace is <code>net.sf.mmm</code>.
      All packages should be sub-packages of these namespace.
      Each component declares a specific package (say <code>net.sf.mmm.foo</code>) 
      and is devided into the following subpackages:
      <ul>
        <li><code>api</code><br/>
        contains the API of the component that should consist only of 
        interfaces and exception classes. It may also contain classes 
        like simple container objects (e.g. event-classes) or utilities.
        </li>
        <li><code>base</code><br/>
        contains the basic implementation of the API that is NOT intended to
        be implemented in another way. It typically contains abstract classes.
        Vendors that want to write a custom implementation of a component
        are supposed to extend these classes rather than directly implementing 
        the API interfaces. If in some specific circumstance the API has to 
        be changed (extended) compatibility can be gained by covering this in 
        the base implementation.
        </li>
        <li><code>impl</code><br/>
        contains the implementation(s) of the component.
        </li>
      </ul>
      Each of these sub-packages may be devided into further sub-sub-packages
      (say <code>net.sf.mmm.foo.api.bar</code>) if desireable according to 
      size and complexity. Users of a component should only use the API what 
      can easily be checked via the import statements. This NOT only applies
      to external users but also to other components of this project, though
      NOT always possible. A container framework is (to be) used for creating
      the components from their implementation. Testcases or very simple applications
      may directly create and setup a component from its implementation.
      </p>
    </section>    
    <section name="Resources">
      Java makes resource handling very easy. The tradeoff is that there are many 
      common mistakes developers do because they stop thinking about resource 
      management.
      <subsection name="Streams">
        If you deal with streams (InputStream, OutputStream, or related stuff) 
        please be very careful to ensure they are closed properly.
        Whenever an API method takes a stream as parameter, the javadoc must 
        specifiy wheter the stream is closed or not. If you want to close
        a stream make proper use of finally statements.
        The following example does NOT always close streams properly:
        <source>
FileInputStream sourceStream = new FileInputStream(source);
FileOutputStream destinationStream = new FileOutputStream(destination);
FileChannel sourceChannel = sourceStream.getChannel();
try {
  sourceChannel.transferTo(0, sourceChannel.size(), destinationStream.getChannel());
} finally {
  destinationStream.close();
  sourceStream.close();
}
        </source>
        A correct version looks as following:
        <source>
FileInputStream sourceStream = new FileInputStream(source);
try {
  FileOutputStream destinationStream = new FileOutputStream(destination);
  try {
    FileChannel sourceChannel = sourceStream.getChannel();
    sourceChannel.transferTo(0, sourceChannel.size(), destinationStream.getChannel());
  } finally {
    destinationStream.close();
  }
} finally {
  sourceStream.close();
}
        </source>        
      </subsection>      
      <subsection name="Dereference">
        The garbarge-collector is a fine thing, but anyways it does NOT prevent
        you from creating memory-holes in your software. Therefore you should
        carefully derefence objects that are no longer needed. This especially
        applies to objects stored in collections. If you use a map to cache
        objects you need to ensure that the cache size can only grow to a 
        defined maximum and objects can still be dereferenced using weak- or
        soft-references.
      </subsection>  
      <subsection name="Classpath-Resources">
        If you want to load a resource from the classpath do NOT use
        the following code-style:
        <source>
InputStream resourceStream = MyClass.class.getResourceAsStream("my-resource.xml");
        </source>
        This will NOT work properly in every environment such as
        some application-servers or frameworks that deal with special 
        class-loaders. Instead use <code>net.sf.mmm.util.resource.ClasspathResource</code>
        as following:
        <source>
DataResource resource = new ClasspathResource(MyClass.class, "my-resource.xml", false);
InputStream resourceStream = resource.openStream();
        </source>
      </subsection>
    </section>    
    <section name="Concurrency">
      In non-functional programming languages it is NOT always easy to deal with 
      cuncurrent access to shared objects. Please avoid static access to
      non-final objects. If you design a class always consider if it is possible
      to do something in a thread-safe way. On the other hand never assume that 
      some implementation is thread-safe if NOT explicitly specified in the javadoc.
    </section>
    <section name="Tests">
      <p>For each sub-project module-tests should verify the integrity of the code.
      Therefore JUnit and its extensions (e.g. XmlUnit) are used. Maven (surefire) 
      is used to verify the unit-tests during the build process. The test-results
      and test-coverage are generated as report per sub-project on the web-site.
      It is hard to reach a high coverage but this is a goal of the project
      to increase the coverage continously.</p>
    </section>
  </body>
</document>

/* $Id: $ */
/*
  This is the javacc grammar file for the ExpressionParser.
  Simply run the command "javacc ExpressionParser.jj" to generate
  the according java code.
*/
options {
	STATIC=false;
}
PARSER_BEGIN(ExpressionParser)
/* $Id: $ */
package net.sf.mmm.term.impl.parser;

import java.util.ArrayList;
import java.util.List;

import net.sf.mmm.term.api.FunctionException;
import net.sf.mmm.term.api.FunctionIF;
import net.sf.mmm.term.api.FunctionServiceIF;
import net.sf.mmm.term.api.TermIF;
import net.sf.mmm.term.impl.Constant;
import net.sf.mmm.term.impl.DummyFunctionService;
import net.sf.mmm.term.impl.Expression;
import net.sf.mmm.term.impl.ExpressionVariable;
import net.sf.mmm.term.base.Variable;
import net.sf.mmm.value.api.ValueException;

/**
 * This file was generated by javacc.
 *
 * @author Joerg Hohwiller (hohwille at users.sourceforge.net)
 */
@SuppressWarnings("all")
public class ExpressionParser {

  /** the function service instance */
  private FunctionServiceIF functionService;

  /**
   * main method for testing...
   */
  public static void main(String args[]) throws Exception {
  	while (true) {
      System.out.println("Enter Expression:");
      ExpressionParser parser = new ExpressionParser(System.in);
      parser.setFunctionService(new DummyFunctionService());
      System.out.println(parser.expression());
    }
  }
  
  /**
   * This method sets the function service.
   *
   * @param service is the function service instance.
   */
  public void setFunctionService(FunctionServiceIF service) {
  	this.functionService = service;
  }

}

PARSER_END(ExpressionParser)

SKIP :
{
	" "
|	"\t"
}

/* constants */
TOKEN:
{
	< TRUE: "true" >
|	< FALSE: "false" >
|	< NULL: "null" >
|	< STRING:
		"\""
		(
			(~["\"","\\","\n","\r"])
			| ("\\"
				( ["n","t","b","r","f","\\","'","\""]
				| ["0"-"7"] ( ["0"-"7"] )?
				| ["0"-"3"] ["0"-"7"] ["0"-"7"] ) )
		)*
		"\""
		>
|	< INTEGER:
		<DECIMAL_INTEGER>
		| <HEX_INTEGER>
		| <OCTAL_INTEGER>
		>
|	< #DECIMAL_INTEGER: ["1"-"9"] (["0"-"9"])* >
|	< #HEX_INTEGER: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|	< #OCTAL_INTEGER: "0" (["0"-"7"])* >
|	< DOUBLE:
		(["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
		| "." (["0"-"9"])+ (<EXPONENT>)?
		| (["0"-"9"])+ <EXPONENT>
		| (["0"-"9"])+ (<EXPONENT>)?
		>
|	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}

/* separators */
TOKEN:
{
	< LPAREN: "(" >
|	< RPAREN: ")" >
|	< LBRACKET: "[" >
|	< RBRACKET: "]" >
|	< COMMA: "," >
|	< DOT: "." >
|	< VARIABLE_START: "${" >
|	< VARIABLE_END: "}" >
}

/* functions and operators */
TOKEN:
{
	< OPERATOR: (<OPERATOR_CHAR>)+ >
|	< #OPERATOR_CHAR: ["+","-","*","/","<",">","=","&","|","!","?",":","\\","%","#",".","~"] >
|	< FUNCTION_NAME: ["a"-"z"](["a"-"z", "A"-"Z"])* >
|	< VARIABLE_NAME: ["a"-"z", "A"-"Z"] ( ["a"-"z", "A"-"Z", "0"-"9", "_", "."] )* >
}

/**
 * This method parses the expression.
 */
TermIF expression() throws ValueException, FunctionException:
{
  List<TermIF> argList = null;
  TermIF t;
  FunctionIF f = null;
  FunctionIF o = null;
}
{
	<LPAREN> t=expression() <RPAREN>
	{
		return t;
	}
|	o=operator() t=expression()
	{
		return new Expression(o, t);
	}
|	t=term() 
	  ( o=operator() 
	    {
	    	argList = new ArrayList<TermIF>();
	    	argList.add(t);
	    }
	  t=term()
	    {
	      if (f == null) {
	    	f = o;
          } else if (o != f) {
	      	if (f.getOperatorPriority().priority < o.getOperatorPriority().priority) {
	      		//requires stack...
	      	}
	      	//3+2*4=3+(2*4)
	      	//3*2+4=(3*2)+4
	      }
	      argList.add(t);
	    }
	  )*
	{
		if (f == null) {
			return t;
		} else {
            return new Expression(f, argList.toArray(new TermIF[argList.size()]));
		}
	}
|	f=function()
		{
			argList = new ArrayList<TermIF>();
		}	  
		<LPAREN> ( t=expression() 
		{
			argList.add(t);
		}
		( <COMMA> t=expression()
		{
			argList.add(t);
		}
		)* ) <RPAREN>
	{
		return new Expression(f, argList.toArray(new TermIF[argList.size()]));
	}
}

/**
 * This method parses an operator.
 */
FunctionIF function() throws FunctionException:
{
	Token fname;
}
{
	fname=<FUNCTION_NAME>
	{
		return this.functionService.getFunctionByName(fname.image);
	}
}

/**
 * This method parses an operator.
 */
FunctionIF operator() throws FunctionException:
{
	Token symbol;
}
{
	symbol=<OPERATOR>
	{
		return this.functionService.getFunctionBySymbol(symbol.image);
	}
}

/**
 * This method parses a term (atom?).
 */
TermIF term() throws ValueException, FunctionException:
{
	TermIF t;
}
{
	<VARIABLE_START> t=variable() <VARIABLE_END>
	{
		return t;
	}
|	t=constant()
	{
		return t;
	}
}

/**
 * This method parses a variable.
 */
TermIF variable() throws ValueException, FunctionException:
{
	Token t;
	TermIF term;
}
{
	t=<LPAREN> term=expression() <RPAREN>
	{
		return new ExpressionVariable(term);
	}
|	t=<FUNCTION_NAME>|t=<VARIABLE_NAME>
	{
		return new Variable(t.image);
	}
}

/**
 * This method parses a constant.
 *
 * @return the constant value as term.
 */
TermIF constant():
{
	Token t;
}
{
  t=<STRING>
    {
    	return new Constant<String>(t.image);
    }
| t=<INTEGER>
  	{
  		return new Constant<Integer>(Integer.valueOf(t.image));
  	}
| t=<DOUBLE>
  	{
  		return new Constant<Double>(Double.valueOf(t.image));
  	}
| t=<TRUE>
  	{
  		return Constant.TRUE;
  	}
| t=<FALSE>
    {
      return Constant.FALSE;
    }
| t=<NULL>
    {
      return Constant.NULL;
    }
}
